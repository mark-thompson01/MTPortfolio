<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ubuntu Server Post-Install Systems Configuration · Mark Thompson Portfolio</title>

<meta name="description" content="Ubuntu Server post-installation baseline lab structured into six operational phases covering validation, updates, access control, SSH hardening, networking, and system readiness." />

<style>
:root{
  --bg-1:#0f1115; --bg-2:#141821; --text:#E6E7EE; --muted:#A9ADBE;
  --brand:#4DA3FF; --card-border:#2A3447; --shadow:0 10px 30px rgba(0,0,0,.35);
  --radius:18px;
} <h4>Why:</h4>
  <ul>
    <li>Clean logs</li>
    <li>Predictable service identity</li>
    <li>Easier monitoring & automation</li>
  </ul><br>
html,body{height:100%}
body{
  margin:0;color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial;
  background:
    radial-gradient(1200px 800px at 30% -20%, #1a2233 0%, transparent 70%),
    radial-gradient(1200px 800px at 90% -10%, #0e1c2f 0%, transparent 70%),
    linear-gradient(180deg,var(--bg-1),var(--bg-2));
  line-height:1.6;
}
.wrap{max-width:1000px;margin:0 auto;padding:40px 20px 64px}

/* Top nav */
.topnav{margin:0 0 18px;display:flex;gap:14px;flex-wrap:wrap}
.topnav a{
  color:var(--muted);text-decoration:none;
  padding:6px 10px;border-radius:10px;border:1px solid transparent
}
.topnav a:hover{
  color:var(--text);border-color:#2a3447;background:rgba(255,255,255,.04)
}
.topnav a.active{
  color:var(--text);border-color:#3a4a67;background:rgba(255,255,255,.06)
}

/* Breadcrumb */
.crumbs{color:var(--muted);font-size:14px;margin:2px 0 10px}
.crumbs a{color:var(--muted);text-decoration:none}
.crumbs a:hover{color:var(--text)}

h1{margin:8px 0 6px;font-size:clamp(28px,4vw,40px)}
h2{margin:0 0 14px;font-size:22px}
.lead{color:var(--muted);font-size:18px;margin:8px 0 18px}
   a{color:var(--brand);text-decoration:none}
    a:hover{text-decoration:underline}
    .lead{color:var(--muted);margin:8px 0 18px;font-size:clamp(16px,2.2vw,18px)}

/* Cards */
.card{
  background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));
  border:1px solid var(--card-border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:22px;
  margin-top:18px;
}

/* Image wrapper */
.figure{
  border:1px solid var(--card-border);
  border-radius:12px;
  background:#0e1220;
  padding:8px;
  margin:14px auto;
  max-width:720px;
  cursor:zoom-in;
}
.figure img{
  display:block;
  max-width:100%;
  height:auto;
  border-radius:8px;
}

/* Lightbox */
.zb-overlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,.85);
  display:none;align-items:center;justify-content:center;
  z-index:9999;
}
.zb-overlay.is-open{display:flex}
.zb-stage{position:relative;max-width:95vw;max-height:92vh;overflow:hidden}
.zb-img{max-width:100%;max-height:100%;border-radius:12px}
.zb-close{
  position:fixed;top:14px;right:14px;
  background:rgba(255,255,255,.08);
  border:1px solid #2a2f3f;
  color:#cfd3e6;padding:8px 10px;border-radius:10px
}

footer{
  margin-top:40px;padding-top:20px;
  border-top:1px solid #232a3a;
  color:var(--muted);font-size:14px;
}
</style>
</head>

<body>
<div class="wrap">

<!-- NAV -->
<nav class="topnav">
  <a href="/MTPortfolio/">Home</a>
  <a href="/MTPortfolio/Skills">Networking</a>
  <a href="/MTPortfolio/Current%20Projects%20&%20Studies/" class="active">Windows & Linux</a>
  <a href="/MTPortfolio/Lab%20Projects">Cybersecurity</a>
  <a href="/MTPortfolio/Blogs">Blog</a>
</nav>
<!-- Breadcrumb -->
<div class="crumbs">
  <a href="/MTPortfolio/Current%20Projects%20&%20Studies/">Windows & Linux</a> ·
  <span>Ubuntu Server Post-Install Systems Configuration</span>
</div>

<header>
  <h1>Ubuntu Server Post-Install Systems Configuration</h1>
  <p class="lead">
    A phase-based systems administration lab that establishes a secure, predictable Ubuntu Server foundation after installing the base server OS prior to service deployment.
  </p>
   <p>
      <a href="https://github.com/mark-thompson01/ubuntu-server-post-install-systems-config/tree/main">
        View this project on GitHub
      </a>
    </p>
</header>

  <section class="card" id="toc">
  <h4>Table of Contents:</h4>
  <ul style="list-style-type: none;">
    <li>
      <a href="#phase-1">
        <strong>Phase 1 - Initial Validation &amp; Environment Awareness</strong>
      </a>
    </li>
    <li>
      <a href="#phase-2">
        <strong>Phase 2 - Identity, Privilege Management, &amp; Access Control</strong>
      </a>
    </li>
    <li>
      <a href="#phase-3">
        <strong>Phase 3 - Networking &amp; Host Identity</strong>
      </a>
    </li>
    <li>
      <a href="#phase-4">
        <strong>Phase 4 - Security Baseline</strong>
      </a>
    </li>
    <li>
      <a href="#phase-5">
        <strong>Phase 5 - Service &amp; System Management</strong>
      </a>
    </li>
    <li>
      <a href="#phase-6">
        <strong>Phase 6 - Logging, Monitoring, &amp; Maintenance</strong>
      </a>
    </li>
  </ul>
</section><br><br>





<!-- PHASES (UNCHANGED CONTENT) -->
<section class="card">
<h2>Phase 1 — Initial Validation & Environment Awareness</h2>
<h3>1. ubuntu-server login:</h3>
<div class="figure"><img src="Images/phase1-1.png"></div>
<div class="figure"><img src="Images/phase1-2.png"></div>

<p>After successful authentication, the system loads directly into a user shell. Root access can be obtained using <code>sudo</code>.</p>
<p>When you download the official Ubuntu Server ISO and install it, 
you get a headless system by default. A headless system is one to where there is no GUI (Graphical User Interface) to login to and manage the system with, it's all done in the Linux terminal via command-line shell.</p>
<p>However, even though the system is headless by default, that doesn't mean you're "locked out" of the GUI. If you find that a specific task is too difficult in the terminal, you can run one command: <code>sudo apt install ubuntu-desktop</code>, this will download about 2GB of data and convert the server into a desktop environment. However, it's a best practice to avoid this because it results in the server becoming slower and less secure. </p>
<p>Even though you can enable a GUI, when it comes to Linux server administration, the ability to be able to effectively and efficiently manage an Ubuntu server system via terminal is widely considered one of the most imperative skills in Linux server administration. </p>
<div class="figure"><img src="Images/phase1-3.png"></div><br><br>

<h3>2. Verify OS, Kernel, and System Health</h3>
<p><strong>Immediately confirm what you're running:</strong></p>
<p>Before proceeding with system configuration, there are some critical verifications to look through, that can really be huge time savers.</p>
<p>These commands are considered the "vital signs" to check on an Ubuntu server system post OS installation, or any Linux server installation for that matter.</p>
<p>Especially when there's only a terminal to work with. These commands help to confirm that the hardware and software components of a given system are functioning as expected before continuing to configure the system further.</p><br><br><br>
<p>I like to start out with commands such as <code>hostname</code>, <code>whoami</code>, <code>pwd</code>, to get an overall feel for the environment that I'm working in.</p>
<p><strong>After going through those, I then go through the following:</strong></p>
<ul>
  <li><code>lsb_release -a & uname -a</code></li>
  <li><code>uptime</code></li>
  <li><code>df -h</code></li>
  <li><code>free -h</code></li>
</ul><br>
  
  
<h4>The System "Identity Check"</h4>
<code>lsb_release -a & uname -a</code>
<ul>
  <li><strong>Why:</strong> You need to verify exactly which version of Ubuntu and which Linux Kernel were installed.</li><br>
  <li><strong>The Goal:</strong> If you intended to install a 
Long Term Support (LTS) version like 24.04 but 
accidentally installed an interin version, you want
want to know before you spend hours configuring it. It also confirms if you are running a 64-bit or ARM-based system.</li>
</ul><br>

<h4>The System "Stability Check"</h4>
  <code>uptime</code>
  <ul>
    <li><strong>Why:</strong> This tells you how long the server has been running and the "load average."</li><br>
    <li><strong>The Goal:</strong> This helps to confirm that the system didn't experience a silent crash or reboot during the final stages of the installation process. If the load average is high on a brand-new install, something is going on with the background processes.</li>
  </ul><br>

  <h4>The System "Storage Check"</h4>
  <code>df -h</code>
  <ul>
  <li><strong>Why:</strong> This shows your disk partitions and how much space is used.</li><br>
  <li><strong>The Goal:</strong> There is a common issue during Ubuntu installations is the "LVM" default, which can sometimes only allocate half of the drive space. Running this command ensures that the server actually sess all the storage you gave it.</li><br>
  <li>The <code>-h</code> makes the command output "human readable" (showing GB instead of raw blocks).</li>
  </ul><br>

  <h4>The System "Memory Check"</h4>
  <code>free -h</code>
  <ul>
    <li><strong>Why:</strong> This displays the system RAM usage and system "Swap" space.</li><br>
    <li><strong>The Goal:</strong> You want to make sure the server is detecting all of the RAM sticks (or the full amount of RAM allocated). If the server is already using 90% of its RAM with nothing installed, that's a sure sign an upgrade is needed well before the deployment stage is reached.</li>
  </ul>
  
<div class="figure"><img src="Images/phase1-4.png"></div><br><br>
  
<h3>3. Update the System (Mandatory First Action)</h3>
<p>After going through the verification of the OS, Kernel, and System Health, updating the system with the latest packages and security patches is an absolute imperative must!</p>
<p><strong>Never configure a stale system:</strong></p>  
<h4>Why</h4>
<ul>
  <li>Security patches</li>
  <li>Kernel fixes</li>
  <li>Package stability before service deployment</li>
</ul>
<code>sudo apt update && apt upgrade -y</code>
  <p>In this example, <code>apt update</code> and <code>apt upgrade</code> are used in a one-line command with the use of the <code>&&</code> (Logical AND) operator, allowing the system to run the two commands sequentially instead of running both commands separately.</p>
  <p>This command chain performs a two-stage maintenance routine that first synchronizes the local system with official software repositories and then applies all available security and stability patches.</p>
  
<div class="figure"><img src="Images/phase1-5.png"></div>
<div class="figure"><img src="Images/phase1-6.png"></div>
<div class="figure"><img src="Images/phase1-7.png"></div>
<div class="figure"><img src="Images/phase1-8.png"></div>

<p>After a significant system upgrade, a <code>sudo reboot</code> is performed to initialize the newly installed Linux Kernel.</p>
<p>Helping to ensure that the system isn't running an outdated or vulnerable kernel and that all system services have been refreshed to utilize the latest patched libraries.</p>  
<div class="figure"><img src="Images/phase1-9.png"></div>
<div class="figure"><img src="Images/phase1-10.png"></div>
<div class="figure"><img src="Images/phase1-11.png"></div>
</section><br><br><br><br>

<section class="card">
<h2>Phase 2 — Identity, Privilege Management & Access Control</h2>
<h3>1. Create a Non-Root Admin User</h3>
<p><strong>Never operate day-to-day as root:</strong></p>
<code>sudo adduser sysadmin</code>
<div class="figure"><img src="Images/phase2-1.png"></div>
<code>groups sysadmin</code>
<div class="figure"><img src="Images/phase2-2.png"></div>
<p>Running <code>groups sysadmin</code> command confirms that the automated part
of the command <code>adduser</code> process works correctly.</p>
<h4>It Shows:</h4>
<ul>
  <li><strong>Primary Group:</strong> The user has their private group ( sysadmin )</li><br>
  <li><strong>Standard Access:</strong> The user was successfully added to the users group, which is the standard pool for non-0administrative accounts on the system.</li>
</ul><br><br>
  
  
  
<p>Creating a Non-Root Admin User account is an action of Account Isolation.</p>
<p>Instead of doing everything through your personal account or the "root" account, this creates a dedicated service account <code>(sysadmin)</code>. This is a key security-step-if one users becomes compromised, the other user accounts remain protected.</p>
<h4>Why:</h4>
  <ul>
    <li>Least privilege</li>
    <li>Auditability</li>
    <li>Industry best practice</li>
  </ul><br>
  <div class="figure"><img src="Images/phase2-3.png"></div><br><br>


<h3>2. Harden SSH Access</h3>
  <p><strong>Edit SSH configuration:</strong></p>
  <code>sudo nano /etc/ssh/sshd_config</code>
<div class="figure"><img src="Images/phase2-4.png"></div>
<div class="figure"><img src="Images/phase2-5.png"></div>
<div class="figure"><img src="Images/phase2-6.png"></div>
<p><strong>Recommended changes:</strong></p>
  <ul style="list-style-type: none;">
    <li>PermitRootlogin no</li>
    <li>PasswordAuthentication no</li>
    <li>PubKeyAuthentication yes</li>
  </ul><br>
<p>Verify/Make necessary changes, <strong>ctrl + o</strong> to save, <strong>ctrl + x</strong> to exit.</p>
<p><strong>Here it shows:</strong></p>
  <ul style="list-style-type: none;">
    <li>PermitRootLogin prohibit-password (no)</li>
    <li>PubKeyAuthentication yes</li>
    <li>PermitRootLogoin prohibit-password (no)-(set-above)</li>
  </ul>
<div class="figure"><img src="Images/phase2-7.png"></div><br>



<p><strong>After making adjustments, restart the ssh service for the changes to take effect:</strong></p>
<code>sudo systemctl restart ssh</code><br>
<code>sudo systemctl status ssh</code>
<div class="figure"><img src="Images/phase2-8.png"></div>

<h4>Why:</h4>
  <ul>
    <li>Prevents brute-force attacks</li>
    <li>Enforces key-based auth</li>
  </ul>
</section><br><br><br><br>


  
<section class="card">
<h2>Phase 3 — Networking & Host Identity</h2>
  <h3>1. Verify Network Configuration (Netplan)</h3>
  <code>ip a</code><br>
  <code>ip route</code>
  <p>The <code>ip a</code> command confirms/verifies the IP configuration details to the systems network adapater.</p>
  <p>Best practice to review the IP configuration details to verify that you have the expected details set for the given configuration.</p>
  <p>The <code>ip route</code> command lists the default routes that are defined on the given system.</p>
  <p>It's a good detail to verify, and a good command to run in different troubleshooting scenarios.</p>
<div class="figure"><img src="Images/phase3-1.png"></div><br>


<h4>View Netplan:</h4>
<code>ls /etc/netplan/</code><br>
<code>sudo nano /etc/netplan/*.yaml</code>
<p>Here, things are moving into network administration with the <strong>Netplan</strong> system utility. Netplan is the default way Ubuntu Server manages network settings like IP addresses, DNS, and gateways.</p>
<p>Running <code>ls /etc/netplan/</code> to see what is available in the /netplan directory.</p>
<p>In this example, the output file is <code>50-cloud-init.yaml</code>.</p>
<p>In Ubuntu systems, network configurations are stored in <strong>YAML</strong> files.</p>
<p>These files are the "instruction manuals" that instruct a <strong>Network Interface Card (NIC)</strong> how to establish an internet connection.</p>
<div class="figure"><img src="Images/phase3-2.png"></div>
<div class="figure"><img src="Images/phase3-3.png"></div><br>


<h4>Apply safely</h4>
<code>sudo netplan try</code><br>
<code>sudo netplan apply</code>
<p><strong>This right here is the most critical part of network configuration:</strong></p>
<p><strong>Committing changes safely!</strong></p>
<p>When you edit network settings on a headless server, there is a high risk of accidentally locking yourself out.</p>
<p>If you type one wrong number in an IP address and hit "apply," the server might lose its connection, and since you don't have a GUI or a local screen, you'd have no way to get back in to fix it.</p>
<br>
<p>The <code>sudo netplan try</code> command applies new network settings temporarily.</p>
  <ul>
    <li><strong>The "Timeout" Feature:</strong> In the output it says "Changes will revert in 115 seconds." It starts a countdown. If you don't press <strong>Enter</strong> within that time, the server assumes something went wrong (like you losing your connection) and automatically rolls back to the old, working settings.</li><br>
    <li><strong>Why it's a lifesaver:</strong> If your new config breaks the internet, you just wait two minutes, and the server "fixes itself" by reverting back to your previous settings.</li>
  </ul><br>

 <p>The <code>sudo netplan apply</code> command is <strong>The "Final Commitment"</strong></p>
  <ul>
    <li><strong>What it does:</strong> Once you've confirmed that <code>netplan try</code> worked and you still have access, you run this to make the changes <strong>permanent</strong>.</li><br>
    <li><stronger>The Result:</stronger> The system writes the configuration to the network stack. These settings will now persist even after the server reboots.</li>
    
  </ul>
  

  
<div class="figure"><img src="Images/phase3-4.png"></div>
<h4>Why:</h4>
  <ul>
    <li>Static IPs for servers</li>
    <li>Prevents accidental lockouts</li>
  </ul>

   <p><strong>Why This is Among One of the First Steps - Post OS Installation:</strong></p>
  <p>In a headless server configuration, the <strong>Network Configuration</strong> is the most critical file. If the file is set up incorrectly, the server goes offline, and you lose your SSH connection. Admins usually have to:</p>
  <ul>
    <li><strong>Set a Static IP:</strong> Ensuring the server's address never changes (so you always know where to SSH).</li><br>
    <li><strong>Configure DNS:</strong> Telling the server which "phonebook" (like Google or Cloudflare) to use to find websites.</li>
  </ul>
  <p>Operational continuity relies heavily on servers with <strong>Network Persistence & Configuration</strong>. To ensure consistent remote access, using <strong>Netplan</strong> to manage the server's network stack, helps to maintain that persistence.</p>
  <p>By auditing the YAML configuration files in <code>/etc/netplan/</code>, you can define static IP assignments and custom DNS resolvers.</p>
  <p>The <code>nano</code> or other text editor CLI of your choice can be used to make changes to the file's configuration details, ensuring the server maintains a reliable 'heartbeat' on the local network, ensuring operations are not disrupted.</p><br>
  
  
  <br><br>


  
<h3>2. Set Hostname & Local Name Resolution</h3>
  <p><strong>Initial System Provisioning</strong></p>
  

  
<code>hostname</code><br>
<code>sudo hostnamectl set-hostname ubuntu-srv01</code><br>
<code>sudo nano /etc/hosts</code> 
  <h4>Add:</h4>
  <ul style="list-style-type: none;">
    <li>127.0.1.1 ubuntu-srv01</li>
  </ul>
  <p>With these commands, the goal is to ensure network clarity and application stability.</p>
  <p>After the initial system health check, it's time setup a recognizable hostname for the system that will be deployed into production that fits its intended purpose.</p>
  <p>Listing out the current default hostname, followed by running the <code>sudo hostnamectl set-hostname</code> command to change the system's hostname to <code>ubuntu-srv01</code>.</p>
  <p>Then mapping the new system hostname to the local loopback address in the <code>/etc/hosts</code> file.</p>
  <p>This prevents 'DNS-lookup lag' and ensures that local services can resolve the system's identity without external network dependencies.</p>
  
<div class="figure"><img src="Images/phase3-5.png"></div>
<div class="figure"><img src="Images/phase3-6.png"></div>
<div class="figure"><img src="Images/phase3-7.png"></div>
    <h4>Why:</h4>
  <ul>
    <li>Clean logs</li>
    <li>Predictable service identity</li>
    <li>Easier monitoring & automation</li>
  </ul>
</section><br><br><br><br>

<section class="card">
<h2>Phase 4 — Security Baseline</h2>
  <h3>1. Configure the Firewall (UFW)</h3>
  <ul>
    <li>Deny incoming traffic by default</li>
    <li>Allow outgoing traffic by default</li>
    <li>Allow OpenSSH</li>
    <li>Enable the ufw Firewall</li>
    <li>List ufw Firewall status</li>
  </ul>
  
  <code>sudo ufw default deny incoming</code><br>
  <code>sudo ufw default allow outgoing</code><br>
  <code>sudo ufw allow OpenSSH</code><br>
  <code>sudo ufw enable</code><br>
  <code>sudo ufw status verbose</code>
<div class="figure"><img src="Images/phase4-1.png"></div>
  <h4>Why:</h4>
<ul>
  <li>Immediate attack surface reduction</li>
  <li>Zero-trust mindset</li>
</ul><br><br>
 

<h3>2. Enable Automatic Security Updates</h3>
<code>sudo apt install unattended-upgrades -y</code>
<div class="figure"><img src="Images/phase4-2.png"></div>
<div class="figure"><img src="Images/phase4-3.png"></div>
<p>To minimize the attack surface and ensure 24/7 security compliance, the <code>unattended-upgrades</code> program can be used to implement <strong>Automated Patch Management</strong>.</p>
<p>This configuration enables the server to autonomously fetch and apply critical security updates from the official Ubuntu repositories.</p>
<p>This proactive approach ensures the system remains resilient against emerging threats without requiring manual intervention, balancing high security with operational stability.</p><br>

<code>sudo dpkg-reconfigure unattended-upgrades</code>
<div class="figure"><img src="Images/phase4-4.png"></div>
<h4>Select Yes when prompted:</h4>
                                             
<div class="figure"><img src="Images/phase4-5.png"></div>
<p>The <code>sudo dpkg-reconfigure unattended-upgrades</code> command is a major step in <strong>Automated Security Management</strong>.</p>
<p>By automating patch management workflows you maintain a proactive security posture.</p>
<p>Enabling automated background delivery of critical security patches.</p>
<p>This approach ensures the server remains resilient against 'Zero-Day' vulnerabilities by synchronizing with official repositories daily, reducing the need for manual intervention while maintaining system uptime and stability.</p>
</section><br><br><br><br>

<section class="card">
<h2>Phase 5 — Service & System Management</h2>
  <h3>1. Install Core SysAdmin Tools</h3>
  <code>sudo apt install -y htop curl wget git net-tools fail2ban</code>
  <p>Install essential commands:</p>
  <ul style="list-style-type: none;">
    <li><code>htop</code></li>
    <li><code>curl</code></li>
    <li><code>wget</code></li>
    <li><code>git</code></li>
    <li><code>net-tools</code></li>
    <li><code>fail2ban</code></li>
  </ul>
<div class="figure"><img src="Images/phase5-1.png"></div>
<div class="figure"><img src="Images/phase5-2.png"></div><br>

<p>The Fail2ban service is a critical open-source intrusion 
prevention service.</p>
  <p>It's designed to harden a server against brute-force attacks.</p>
  <p>It does by configuring 'jails,' the system dynamically monitors SSH authentication logs and proactively bans malicious IP addresses.</p>
  <p>This automation significantly reduces the server's attack surface and ensures that system resources are reserved for legitimate users.</p><br>

  <h4>Enabling fail2ban</h4>
<code>sudo systemctl enable fail2ban --now</code>
<div class="figure"><img src="Images/phase5-3.png"></div>
<div class="figure"><img src="Images/phase5-4.png"></div><br>
<code>systemctl list-units --type=service --state=running</code>
<div class="figure"><img src="Images/phase5-5.png"></div>
  <p>This is the terminal equivalent of opening the <strong>"Processes"</strong> tab in a Windows Taks Manager or Activity Monitor on a Mac.</p>
<div class="figure"><img src="Images/phase5-6.png"></div>
</section><br><br><br><br>

<section class="card">
<h2>Phase 6 — Logging, Monitoring & Maintenance</h2>
  <h3>1. Log Inspection</h3>
  <code>journalctl -p 3 -xb</code>
<div class="figure"><img src="Images/phase6-1.png"></div>
<div class="figure"><img src="Images/phase6-2.png"></div>
  <p>In this example, I utilized <code>journalctl -p 3 -xb</code> as a primary diagnostic tool to run a high-priority log inspection.</p>
  <p>By filtering for Priority 3 (Error-level) events within the current boot descriptro, to be able to bypass non-critical system telemetry and immediately isolate service failures or kernel exceptions that could impact system stability.</p>


  <br>

<h3>2. Check auth logs</h3>
<code>sudo tail -f /var/log/auth.log</code>
<div class="figure"><img src="Images/phase6-3.png"></div>
<div class="figure"><img src="Images/phase6-4.png"></div>
<p>Simultaneously, I used <code>tail -f</code> on the authentication logs <code>(auth.log)</code> to establish a <strong>Live Security Feed,</strong> allowing for real-time observation of user sessions and authentication attempts.</p>
<p>This approach ensures total visibility into both system stability and security integrity.</p>
  <h4>Why:</h4>
  <ul>
    <li>Early intrusion detection</li>
    <li>Debugging misconfigurations</li>
  </ul><br><br>

  <h3>3. Backup Awareness (Often Ignored)</h3>
  <p><strong>Even if you don't implement backups yet:</strong></p>
  <code>ls /etc</code><br>
  <code>ls /var</code><br>

  <p>In establishing a robust disaster recovery plan, it's absolutely imperative to prioritize the <code>/etc</code> and <code>/var</code> directories.</p>
  <p>Backing up <code>/etc</code> preserves the <strong>System State</strong>, capturing all custom configurations, security policies, and network definitions.</p>
  <p>Meanwhile, backing up <code>/var</code> ensures preservation of <strong>Operational Data</strong>, including critical security logs and application databases.</p>
  <p>Together, these backups allow for a rapid 'Bare Metal' recovery, ensuring that the system can be restored to its exact functional state in the event of hardware failure or data corruption.</p>
  
  </section>

  <p><a href="../index.html">Back to Home</a></p>

  <!-- FOOTER -->
  <footer>
    <div>Mark Thompson · MTPortfolio</div>
    <div class="links">
      <a href="https://www.linkedin.com/in/mark-thompson-9361a81a9/" target="_blank" rel="noopener">LinkedIn</a> ·
      <a href="https://github.com/mark-thompson01" target="_blank" rel="noopener">GitHub</a>
    </div>
  </footer>

</div>

<!-- Lightbox Script -->
<script>
const imgs = document.querySelectorAll('.figure img');
const overlay = document.createElement('div');
overlay.className = 'zb-overlay';
overlay.innerHTML = '<button class="zb-close">Close</button><div class="zb-stage"><img class="zb-img"></div>';
document.body.appendChild(overlay);

const zimg = overlay.querySelector('.zb-img');
const close = overlay.querySelector('.zb-close');

imgs.forEach(img=>{
  img.onclick=()=>{
    zimg.src=img.src;
    overlay.classList.add('is-open');
  };
});
close.onclick=()=>overlay.classList.remove('is-open');
overlay.onclick=e=>{if(e.target===overlay)overlay.classList.remove('is-open');};
window.onkeydown=e=>{if(e.key==='Escape')overlay.classList.remove('is-open');};
</script>

</body>
</html>
