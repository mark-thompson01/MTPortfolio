
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PowerShell Fundamentals Tutorial</title>
</head>
      <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1e1e1e;
      color: #e0e0e0;
      padding: 2rem;
    }
    h1, h2 {
      color: #ADD8E6;
    }
    code {
      background-color: #333;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      display: block;
      white-space: pre-wrap;
      margin: 0.5rem 0;
    }
    section {
      margin-bottom: 2rem;
    }
        table {
      border-collapse: collapse;
      width: 600px;
    }
    th, td {
      padding: 6px 12px;
      text-align: left;
    }
    th {
      font-weight: bold;
    }
    tr:not(:last-child) {
      border-bottom: 1px solid #444;
    }
          img {
         display: block;
         margin: 20px 0;
         max-width: 75%;
         height: auto;
         border: 1px solid #444;
         border-radius: 5px;
    }
  </style>
<body>
    <h1>PowerShell Fundamentals</h1>

    <h2Introduction: What is PowerShell?</h2>
    <p>PowerShell is a powerful command-line shell and scripting language built on .NET and .Core Frameworks depending on the version. Designed for system administrators and power users, it automates repetitive tasks, manages system configurations, and interacts with APIs, registry, and file systems. It is object-based (unlike traditional text-based shells), meaning it passes objects between commands (not just raw text), which gives it unique flexibility.</p><br>


        
    <h2>Getting Started with PowerShell</h2>
    <ul>
        <li>.NET and .Core Frameworks</li><br>
        <li>PowerShell versions (Windows PowerShell vs PowerShell Core)</li><br>
        <li>Cmdlets & Basic Syntax and Structure</li><br>
        <li>Working with Files and Directories</li><br>
        <li>PowerShell Scripting Basics</li><br>
        <li>Real World Cases</li>
    </ul><br><br>

    <h2>.NET and .Core Frameworks</h2>

         <h3>.NET Framework</h3>
        <p>The <strong>.NET Framework</strong> is the <strong>core powerhouse behind PowerShell's intelligence.</strong> It's not just a programming platform - it's the engine that gives PowerShell its ability to  work with complex data, interact with the Windows operating system, and control almost every part of your system with precision. When you run a cmdlet like <strong>Get-Process</strong> or manipulate objects with <strong>Select-Object</strong>, you're tapping directly into the .NET 's rich library of pre-built classes and methods.</p>
        <p>In simple terms, the .NET Framework provides PowerShell with:</p>

        <ul>
            <li><strong>Access to powerful libraries</strong> that can read files, query networks, and manage Windows services</li><br>
            <li>A<strong> runtime environment (CLR)</strong> that handles memory, execution, and error handling.</li><br>
            <li>The ability to treat data as <strong>objects</strong>, not plain text - allowing advanced filtering, formatting, and manipulation.</li>
        </ul>

        <p>PowerShell isn't just a shell - it's a scripting language deeply rooted in the .NET ecosystem, which is why it can do far more than traditional shells. Every command you run inherits the <strong>depth and structure of .NET</strong>, turning simle commands into powerful, scalable automation scripts.</p><br>

    <h3>.Core Framework</h3>
    <p>The <strong>.NET Core Framework</strong> is the modern, cross-platform foundation behind PowerShell Core's flexibility and reach.</p>
        <p>Unlike the tradtional .NET Framework, which is Windows-specific, the .NET Core is designed more for portability, allowing PowerShell Core to be cross-platform (Windows, Linux, macOS). It's modular, lightweight, and fast. It's built to meet the demands of modern automation.</p>
        <p>The .NET Core Framework provides PowerShell Core with:</p>
    <ul>
        <li><strong>Cross-platform compatibility:</strong> Enables consistent scripting and automation across Windows, macOS, and Linux environments.</li>
        <li><strong>Performance and modularity:</strong> Through a streamlined runtime and lightweight libraries that support efficient execution and scalable scripts.</li>
        <li><strong>Open-source development:</strong> Giving users access to the latest features, community contributions, and rapid improvements in the PowerShell ecosystem.</li>
    </ul>

    <p>PowerShell Core is a foward-looking scripting solution that is built on the .NET Core foundation. Often used for diverse tasks such as managing servers, deploying containers, or scripting across different platforms, PowerShell Core with .NET Core brings the power of .NET to modern automation.</p><br><br>
        

    <h2>Windows PowerShell and PowerShell Core</h2>
    <p>The differences between Windows PowerShell and PowerShell Core lie within platform support, runtime, and development direction.</p>

    <h3>Platform and Version</h3>
    <h4>Windows PowerShell</h4>
        <p><strong>Features:</strong></p>
        <ul>
            <li><strong>Version:</strong> 5.1 (latest and final)</li>
            <li><strong>Platform:</strong> Windows-only</li>
            <li><strong>Runtime Environment:</strong> .NET Framework</li>
            <li><strong>Compatibility:</strong> Works with older Windows APIs</li>
        </ul>

    <h4>PowerShell Core<h4>
        <p><strong>Features:</strong></p>
        <ul>
            <li><strong>Version:</strong> 6.x and 7.x (latest PowerShell 7)</li>
            <li><strong>Platform:</strong> <strong>Cross-platform</strong> (Windows, macOS, Linux)</li>
            <li><strong>Runtime Environment:</strong> .NET Core / .NET 5+</li>
            <li><strong>Compatibility:</strong> Faster, modular, but lacks some Windows-only features</li>
        </ul><br><br>
    
        
 

    <h2>Cmdlets & Basic Syntax and structure</h2>
    <p><strong>Cmdlet</strong> = Command + Let (lightweight commands)</p>
        <p>Cmdlets are the <strong>precision tools</strong> of PowerShell - small but powerful commands that do one job and do it well. Cmdlets can be thought of as individual <strong>building blocks</strong> in a high performance automation toolkit. Written in the .NET Framework and designed specifically for administrative tasks, each cmdlet follows a clear <strong>Verb-Noun</strong> format, making it easy to guess and intuitive to learn. Unlike traditional shell commands that output plain text, cmdlets output <strong>structured objects</strong>, allowing you to filter, sort, and manipulate data with accuracy. Whether you're  pulling system info, managing users, or stopping rogue services, cmdlets are your go-to tools for scripting control and operational mastery.</code></strong></p>

    <h3>Naming Format</h3>
        <p>Cmdlets use a <strong>Verb-Noun</strong> naming pattern for clarity and consistency:</p>

         <table>
    <thead>
      <tr>
        <th>Verb</th>
        <th>Noun</th>
        <th>Meaning</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="tag">Get-</span></td>
        <td><span class="tag">Help</span></td>
        <td><span class="tag">Displays help info about cmdlets</td>
      </tr>
      <tr>
          <td><span class="tag">Get-</span></td>
          <td><span class="tag">Command</span</td>
          <td><span class="tag">Lists available cmdlets</span></td>
      <tr>
        <td><span class="tag">Get-</span></td>
        <td><span class="tag">Process</span></td>
        <td>Show running processes</td>
      </tr>
      <tr>
          <td><span class="tag">Get-</span></td>
          <td><span class="tag">Service</span></td>
          <td>Show running services</td>
      </tr>
      <tr>
        <td><span class="tag">Start-</span></td>
        <td><span class="tag">Service</span></td>
        <td>Start a specific service</td>
      </tr>
     <tr>
         <td><span class="tag">Restart-</span></td>
         <td><span class="tag">Service</span></td>
         <td>Restart a specific service</td>
     </tr>
     <tr>
         <td><span class="tag">Stop-</span></td>
         <td><span class="tag">Service</span></td>
         <td>Stop a specific service</td>
     </tr>
        
    </tbody>
  </table>

        <img src="Images/GetHelp.png" alt="GetHelp.png">
        <img src="Images/GetCommand.png" alt="GetCommand.png">
        <img src="Images/GetProcess.png" alt="GetProcess.png">
        <img src="Images/GetService.png" alt="GetService.png">
        <img src="Images/ServiceMgmt.png" alt="ServiceMgmt.png"><br><br><br>
        
    
        
    <h2>Exploration</h2>  


        <pre><code>
            $PSVersion
            Get-Module -ListAvailable
            Get-Command -Module ModuleName
            List Command -Module ModuleName
            Get-FileHash
            Get-FileHash -Algorithm SHA1 path
            NetAdapter
            Select-Object
            NetAdapter | Select-Object Name, Status, LinkSpeed
            Set-NetFirewallRule -DisplayGroup "File and Printer Sharing" -Enable True
            Get-NetFirewall -DisplayGroup "Network Discovery"
            Get-WmiObject -query 'select*from SoftwareLicensingService').OA3xOriginalProductKey
            wmic bios get serialnumber
            New-NetFirewallRule -DisplayName "Block Specific IP" -Direction Inbound -Action Block -RemoteAddress "192.168.1.100" -Protocol Any
            New-NetFirewallRule -DisplayName "Block Specific IP Outbound" -Direction Outbound -Action Block -RemoteAddress "192.168.1.100" -Protocol Any 
            Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion
            net user username /passworddchg:no
            net user username /passworddchg:yes
            net users
            net groups
            net user administrator
            Get-LocalGroupMember -Group "Administrators"
            Remove-LocalGroupMember -Group "Administrators" -Member "Domain Users"
        </code></pre>

        <p><strong>Get-Module -ListAvailable</strong></p>
        <img src="Images/Exploration/GetModule.png" alt="GetModule.png">
        <img src="Images/Exploration/GetModules2.png" alt="GetModules2.png"><br>
        <p><strong>Get-Module -ListAvailable NetSecurity</strong></p>
          <img src="Images/Exploration/NetFirewall1.png" alt="NetFirewall1.png">
        <p><strong>Get-Command -Module WindowsUpdate</strong></p>
        <img src="Images/Exploration/GetCommand1.png" alt="GetCommand1.png"><br>
        <p><strong>Get-Command -Module NetAdapter</strong></p>
        <img src="Images/Exploration/GetCommand2.png" alt="GetCommand2.png"><br>
        <p><strong>Get-Command -Module NetTCPIP</strong></p>
        <img src="Images/Exploration/GetCommand3.png" alt="GetCommand3.png"><br>
        <p><strong>Get-Command -Module TroubleshootingPack</strong></p>
        <img src="Images/Exploration/GetCommand4.png" alt="GetCommand4.png"><br>
        <p><strong>Get-Command -Module NetworkConnectivityStatus</strong></p>
        <img src="Images/Exploration/GetCommand5.png" alt="GetCommand5.png"><br>
        <p><strong>Get-Command -Module NetSecurity</strong></p>
        <img src="Images/Exploration/GetCommand6.png" alt="GetCommand6.png"><br>
        <p><strong>Get-FileHash</strong></p>
        <img src="Images/Exploration/GetFileHash1.png" alt="GetFileHash1.png"><br>
        <p><strong>NetAdapter</strong></p>
        <img src="Images/Exploration/NetAdapter.png" alt="NetAdapter.png"><br>
        <p><strong>NetAdapter | Select-Object Name, Status, LinkSpeed</strong></p>
        <img src="Images/Exploration/NetAdapter2.png" alt="NetAdapter2.png"><br>
        <p><strong>Set-NetFirewallRule -DisplayGroup "File and Printer Sharing" -Enable True</strong></p>
        <img src="Images/SetNetFirewall.png" alt="SetNetFirewall.png"><br>
        <p><strong>Get-NetFirewallRule -DisplayGroup "Network Discovery"</strong></p>
        <img src="Images/Get-NetworkFirewall.png" alt="Get-NetworkFirewall.png"><br>
        <p><strong>Retrieve computer serial number</strong></p>
        <img src="Images/serialn.png" alt="serial.png"><br>
        <p><strong>New-NetFirewallRule -DisplayName "Block Specific IP" -Direction Inbound -Action Block -RemoteAddress "192.168.1.100" -Protocol Any</strong></p><br>
        <img src="Images/FirewallBlock.png" alt="FirewallBlock.png"><br>
        <p><strong>New-NetFirewallRule -DisplayName "Block Specific IP" -Direction Outbound -Action Block -RemoteAddress "192.168.1.100" -Protocol Any</strong></p>
        <img src="Images/FirewallBlock2.png" alt="FirewallBlock2.png"><br>
        <p><strong>Get-ComputerInfo</strong></p>
        <img src="Images/Exploration/ComputerInfo.png" alt="ComputerInfo1.png"><br>
        <p><strong>Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion</strong></p>
        <img src="Images/ComputerInfo2.png" alt="ComputerInfo2.png">
        <img src="Images/ComputerInfo3.png" alt="ComputerInfo3.png"><br>
        <p><strong>net users</strong></p>
        <img src="Images/netuser.png" alt="netuser.png"><br>
        <p><strong>net groups</strong></p>
        <img src="Images/netgroup.png" alt="netgroup.png"><br>
        <p><strong>net user administrator</strong></p>
        <img src="Images/netuseradmin.png" alt="netuseradmin.png"><br>
        <p><strong>Get-LocalGroupMember -Group "Administrators"</strong></p>
        <img
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

    <h2>Working with Files and Directories</h2>
    <pre><code>Get-ChildItem
New-Item
Get-ChildItem
Remove-Item
echo
mkdir
Move-Item
Copy-Item
ls
    </code></pre>

<p1>The Linux commands mkdir, echo, ls, among others can be used in a PowerShell session.</p1>

<img src="Images/FileDir/NewItem.png" alt="NewItem.png">
<img src="Images/FileDir/GetChildItem.png" alt="GetChildItem.png">
<img src="Images/FileDir/RemoveItem.png" alt="RemoveItem.png">
<img src="Images/FileDir/echomkdir.png" alt="echomkdir.png">
<img src="Images/FileDir/Item.png" alt="Item.png"><br>
        

    <h2>PowerShell Scripting Basics</h2>
    <p>The following outlines PowerShell Scripting Basics that introduce the core building blocks of automation and system administration with the use of Microsoft's powerful command-line shell and scripting language.

        
    <p><strong>Data Types:</strong></p>
    <ul>
        <li><strong>variable:</strong> Variables are named storage locations used to store data that a script can reference, modify, or pass to commands.</li>
        <li><strong>string:</strong> Strings represent sequence of characters in the form of text.</li>
        <li><strong>int:</strong> int - integer is used to represent whole numbers that are both positive and negative.</li>
        <li><strong>array:</strong> A collection of values in a single variable. It allows you to store multiple items, such as strings, numbers, as well as objects, in an ordered list.</li>
        <li><strong>boolean:</strong> Booleans are used to represent truth values and are most commonly used in conditional logic, such as if statements and comparisons.</li>
        <li><strong>object:</strong> An object is a structured unit of data that contains properties and methods.</li>
    </ul><br>
        
    <h3>Variables</h3>
    <pre><code>$Name = "Dave"
$Age = 29
$Services = Get-Service
    </code></pre>
    <p>Variables start with <code>$</code><br></p><br>

<img src="Images/BS/var.png" alt="var.png"><br>

 <h3>Strings</h3>
<pre><code>$greeting = "Hello, world"
    $path = 'C:\Users\Dave'
</code></pre>

<img src="Images/BS/strings.png" alt="strings.png"><br>
        

<h3>Integers</h3>
        <pre><code>
            $a = 10
            $b = 5
        </code></pre>

<img src="Images/BS/Integers.png" alt="Integers.png"><br>
        

<h3>Arrays</h3>
        <pre><code>
            # Creating an array of strings
            $colors = @("Red", "Green", "Blue")

            # Accessing elements by index
            Write-Output $colors[0] # Output: Red
            Write-Output $colors[1] # Output: Green
            Write-Output $colors[2] # Output: Blue
        </code></pre>

        <img src="Images/BS/array.png" alt="array.png">        

        <p>Adding Items to an Array:</p>
        <pre><code>
            $colors += "Yellow" # Adds a new item
            Write-Output $colors # Output: Red Green Blue Yellow
        </code></pre>

        <img src="Images/BS/array2.png" alt="array2.png">
        

        <p>Looping Through an Array:</p>
        <pre><code>
            foreach ($color in $colors) {
                Write-Output "Color: $color:
            }
        </code></pre>

        <img src="Images/BS/arrays3.png" alt="arrays3.png"><br>

    <h3>Booleans</h3>
        <pre><code>
            $isLoggedIn = $true
            $isAdmin = $false
        </code></pre>

        <img src="Images/BS/boolean1.png" alt="boolean1.png">
        

    <p>Using Boolean in if statements:</p>
        <pre><code>
            if ($isLoggedIn) {
                Write-Output "Access granted."
            } else {
                Write-Output "Access denied."
            }
        </code></pre>

        <img src="Images/BS/arrays3.png" alt="array3.png">

        <p>Boolean Result from a Comparison:</p>
        <pre><code>
            $a = 10
            $b = 5

            $isGreater = $a -gt $b  # true
            Write-Output $isGreater # Output: True
        </code></pre>

        <img src="Images/BS/boolean3.png" alt="boolean3.png">

        <p>Logical Operators:</p>
        <pre><code>
            $hasPermission = $true
            $isOwner = $false

            if ($hasPermission -and $isOwner) {
                "You can delete this file."
            } elseif ($hasPermissions -or $isOwner) {
                "You can view the file."
            } else {
                "Access denied."
            }
        </code></pre>

        <img src="Images/BS/boolean4.png" alt="boolean4.png">

        <p>Using -not to Flip a Boolean:</p>
        <pre><code>
            $isAvailable = $false

            if (-not $isAvailable) {
                "Resource is not available."
            }
        </code></pre>

        <img src="Images/BS/Boolean5.png" alt="Boolean5.png"><br>


    <h3>Loops and Conditional Statements</h3>
    <pre><code># If-Else
if ($Age -gt 18) {
    Write-Output "Adult"
} else {
    Write-Output "Minor"
}

# ForEach Loop
$services = Get-Service
foreach ($service in $services) {
    Write-Output $service.DisplayName
}
    </code></pre>

<img src="Images/BS/loops.png" alt="loops.png"><br>

     <h3>Objects</h3>
        <pre><code>
            $process = Get-Process notepad
        </code></pre>
        <p>The variable $process is now an object with properties such as Name, Id, CPU, etc.</p>
        <p>You can access those properties like this:</p>
        <pre><code>
            $process.Name  # Output: Notepad
            $process.Id    # Output: (the process ID)
        </code></pre>

        <img src="Images/BS/objects1.png" alt="objects1.png">
        

<p1>Checking Object Members with Get-Member:</p1>
        <pre><code>
            $process | Get-Member
        </code></pre>

    <img src="Images/BS/objects1.png" alt="objects1.png"

<p>Creating a Custom Object:</p>
        <pre><code>
            $user = [PSCustomObject]@{
                FirstName = "Mark"
                LastName = "Thompson"
                Age = 00
            }

            $user.FirstName  # Output: Mark
            $user.Age        # Output: 00
        </code></pre>

        <img src="Images/BS/objects3.png" alt="objects3.png">

<p>Array of Objects:</p>
        <pre><code>
            $users = @(
                [PSCustomObject]@{ Name = "Alice"; Role = "Admin" },
                [PSCustomObject]@{ Name = "Bob"; Role = "User" }
            )

            foreach ($u in $users) {
                Write-Output "$(Su.Name) is a $($u.Role)"
            }
        </code></pre>

        <img src="Images/BS/objects4.png" alt="objects4.png">

<p>Object Filtering:</p>
        <pre><code>
            $service = Get-Service
            $running = $services | Where-Object { $_.Status -eq "Running" }
        </code></pre>

        <img src="Images/BS/objects5.png" alt="objects5.png"><br>
        

    <h3>Functions</h3>
    <pre><code>function Greet-User {
    param ($Name)
    Write-Output "Welcome, $Name!"
}

Greet-User -Name "Dave"
    </code></pre>
        <img src="Images/BS/function.png" alt="function.png">

<p>simple Function (No Parameters)</p>
        <pre><code>
            function Say-Hello {
                Write-Output "Hello, world!"
            }

            # Call the function
            Say-Hello
        </code></pre>

        <img src="Images/function1.png" alt="function1.png">
        

<p>Function with One Parameter</p>
        <pre><code>
            function Greet-User {
                param($name)
                Write-Output "Hello, $name!"
            }

            Greet-User -name "Mark"
        </code></pre>

        <img src="Images/function2.png" alt="function2.png">
        


<p>Function with Multiple Parameters</p>
        <pre><code>
            function Add-Numnbers {
                param($a, $b)
                $sum = $a + $b
                Write-Output "The sum is $sum"
            }

            Add-Numbers -a 5 -b 10     # Output: The sum is 15
        </code></pre>

        <img src="Images/function3.png" alt="function3.png">
        

    <p>Function with Conditional Logic</p>
        <pre><code>
            function Check-Age {
                param($age)

                if ($age -ge 18) {
                    "You're an adult."
                } else {
                    "You're a minor."
                }
            }

            Check-Age -age 20
        </code></pre>

        <img src="Images/fucntion4.png" alt="fucntion4.png">


        <p>Function that Returns a Value</p>
        <pre><code>
            function Multiply {
                param($x, $y)
                return $x * $y
            }

            $result = Multiply -x 4 -y 6
            Write-Output "Result: $result"
        </code></pre>

        <img src="Images/function5.png" alt="function5.png">



        
    <p>Create reusable code blocks</p><br>
        
    <p>Scripts end with the <strong>.ps1</strong> extension<code>.ps1</code></p><br>



    <h3>Permissions and Execution Policy</h3>
    <pre><code>Get-ExecutionPolicy
Set-ExecutionPolicy RemoteSigned
    </code></pre>

<img src="Images/ExecutePolicy.png" alt="ExecutePolicy.png">
        
    <p><strong>Policies:</strong></p>
    <ul>
        <li>Restricted</li>
        <li>AllSigned</li>
        <li>RemoteSigned</li>
        <li>Unrestricted</li>
    </ul>
        
    <p>Might need admin privileges</p>


    <h3>Useful Tools and Debugging</h3>
    <ul>
        <li><code>Write-Host</code> vs <code>Write-Output</code></li>
        <li><code>Start-Transcript</code> to log sessions</li>
        <li><code>Try / Catch / Finally</code> for error handling</li>
    </ul>

    <p><strong>Write-Host:</strong></p>

    <p>Write-Host is used to display output directly output directly to the console.</p>
        <pre><code>
            function Test-ConnectionStatus {
                param($server)

                Write-Host "Starting connection check..." -ForegroundColor Cyan

                if (Test-Connection -ComputerName $server -Count 1 -Quiet) {
                    Write-Host "$server is online." -ForegroundColor Green
                } else {
                    Write-Host "$server is offline or unreachable." -ForegroundColor Red
                }

                Write-Host "Finished connection check." -ForegroundColor Cyan
            }

            Test-ConnectionStatus -server "example.com"
        </code></pre>

        <img src="Images/Debug/WriteHost.png" alt="WriteHost.png">
        

        


  <p><strong>Write-Output:</strong></p>

  <p>Write-Output sends data to the output stream, which makes it available for further use such as
  capturing into a variable, piping to another command, and redirecting a file.</p>
    <pre><code>try {
    Get-Item "C:\fakefile.txt"
} catch {
    Write-Output "File not found!"
}
    </code></pre>

    <img src="Images/BS/file.png" alt="file.png"><br>

<p><strong>Start-Transcript:</strong></p>
<p>Start-Transcript is a built-in command that starts recording everything that happens in the PowerShell session, including the commands run, their output, errors, and messages to a log file.</p>
        <pre><code>
            # Start logging the session
            Start-Transcript -Path "C:\Logs\debug-log.txt" -Append

            Write-Host "Starting server check..."

            $server = "example.com"

            Write-Host "Pinging $server..."
            if (Test-Connection -ComputerName $server -Count 1 -Quiet) {
                Write-Host "$server is online."
            } else {
                Write-Host "$server is offline or unreachable."
            }

            Write-Host "Script complete."

            # Stop logging
            Stop-Transcript
        </code></pre>

        <img src="Images/Debug/StartTranscript.png" alt="StartTranscript.png">

    <p><strong>Try/Catch</strong> - Basic Try/Catch Block:</p>
    <pre><code>
        try {
            # This will fail if the file doesn't exist
            Get-Content "C:\missing-file.txt"
        }
        catch {
            Write-Host "An error occurred: $_"
        }
    </code></pre>

        <img src="Images/Debug/try1.png" alt="try1.png">
        

        <p>Try/Catch with a Specific Error Action</p>
        <pre><code>
            try {
                # Force PowerShell to treat the error as terminating
                Remove-Item "C:\nonexistent.txt" -ErrorAction Stop
            }
            catch {
                Write-Host "Failed to delete file: $_"
            }
        </code></pre>

        <img src="Images/Debug/try2.png" alt="try2.png">

    <p><strong>Finally:</strong></p>
    <p>Using Finaly to Always Run Cleanup</p>
    <pre><code>
        try {
            Write-Host "Trying risky operation..."
            Get-Content "C:\nonexistent.txt" -ErrorAction stop
        }
        catch {
            Write-Host "Caught an error: $_"
        }
        finally {
            Write-Host "Cleaning up... This always runs."
        }
    </code></pre>

        <img src="Images/Debug/finallty.png" alt="finallty.png">

        <ul>
            <li>Use <strong>try/catch</strong> to gracefully handle errors.</li>
            <li>Use <strong>finally</strong> for cleanup tasks that must run regardless</li>
            <li>Add <strong>-ErrorAction Stop</strong> to make sure non-terminating errors are caught</li>
        </ul><br>

    <h2>Real-World Use Cases</h2>
    <ul>
        <li>Batch user creation in AD</li>
        <li>Automating updates</li>
        <li>Backing up and archiving logs</li>
        <li>Scheduled tasks and reporting</li>
    </ul><br>

    <h3>Automating updates</h3>
    <img src="Images/WindowsUpdate.png" alt="WindowsUpdate.png">
    <img src="Images/WindowsUpdate2.png" alt="WindowsUpdate2.png">
    <img src="Images/WindowsUpdate3.png" alt="WindowsUpdate3.png"><br>

    <h2>Conclusion</h2>
    <p>PowerShell gives IT professionals control and automation in ways that save time, reduce errors, and increase system reliability. Mastering its fundamentals is the first step to becoming a true IT automation pro.</p>

         <a href="../index.html">Back to Home</a>
</body>
</html>

