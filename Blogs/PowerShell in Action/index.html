<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PowerShell in Action · Mark Thompson Portfolio</title>
  <meta name="description" content="A practical, hands-on PowerShell guide covering core cmdlets, pipelines, scripting, data handling, OS interaction, and PowerShell on Linux Ubuntu." />
  <style>
    :root {
      --bg-1:#0f1115; --bg-2:#141821; --text:#E6E7EE; --muted:#A9ADBE;
      --brand:#4DA3FF; --card-border:#2A3447; --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
    }

    html, body {height:100%}
    body {
      margin:0; color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans";
      background:
        radial-gradient(1200px 800px at 30% -20%, #1a2233 0%, transparent 70%),
        radial-gradient(1200px 800px at 90% -10%, #0e1c2f 0%, transparent 70%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      line-height:1.6; -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    }

    .wrap {max-width:1000px; margin:0 auto; padding:40px 20px 64px}

    .topnav {margin:0 0 18px; display:flex; gap:14px; flex-wrap:wrap}
    .topnav a {color:var(--muted); text-decoration:none; padding:6px 10px; border-radius:10px; border:1px solid transparent}
    .topnav a:hover {color:var(--text); border-color:#2a3447; background:rgba(255,255,255,.04)}
    .topnav a.active {color:var(--text); border-color:#3a4a67; background:rgba(255,255,255,.06)}

    .crumbs {color:var(--muted); font-size:14px; margin:2px 0 8px}
    .crumbs a {color:var(--muted); text-decoration:none}
    .crumbs a:hover {color:var(--text)}

    h1 {margin:8px 0 6px; font-size:clamp(28px,4vw,40px); font-weight:800}
    h2 {margin:10px 0 8px; font-size:22px; color:var(--brand)}
    p.lead {color:var(--muted); margin:8px 0 14px; font-size:clamp(16px,2.2vw,18px)}

    .card {
      background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));
      border:1px solid var(--card-border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:20px;
      margin-top:20px;
    }

    .figure {margin:18px auto; width:90%; max-width:700px; transition:transform 0.25s ease, box-shadow 0.25s ease;}
    .figure img {display:block; height:auto; width:100%; border-radius:8px; transition:transform 0.3s ease;}
    .zoom img:hover {transform:scale(1.07); box-shadow:0 0 25px rgba(77,163,255,.25); cursor:zoom-in;}
    .full img {width:auto; max-width:100%;}

    footer {margin-top:36px; padding-top:20px; border-top:1px solid #232a3a; color:var(--muted); font-size:14px;}
    footer .links {margin-top:8px}
    footer a {color:var(--muted)} footer a:hover {color:var(--brand)}
  </style>
</head>
<body>
  <div class="wrap">

    <nav class="topnav" aria-label="Sections">
      <a href="/MTPortfolio/">Home</a>
      <a href="/MTPortfolio/Skills">Networking</a>
      <a href="/MTPortfolio/Current%20Projects%20&%20Studies/">Windows & Linux</a>
      <a href="/MTPortfolio/Lab%20Projects">Cybersecurity</a>
      <a href="/MTPortfolio/Blogs" class="active">Blog</a>
    </nav>

    <div class="crumbs">
      <a href="/MTPortfolio/Blogs">Blog</a> · <span>PowerShell in Action</span>
    </div>

    <header>
      <div class="figure">
        <img src="Images/PowerShellInAction.png" alt="PowerShell in Action blog header" style="width:600px; height:auto;" loading="lazy" />
      </div>
      <h1>PowerShell in Action: Hands-on Examples That Change How You Work</h1>
      <p class="lead">A hands-on continuation of my previous PowerShell blog that takes a practical approach to showing how PowerShell changes the way you interact with a system.</p>
      <p>Kicking things off with core cmdlets, followed by examples of working with pipelines, accessing data without string parsing, running simple scripts to save time, interacting with the operating system, and a step-by-step example of setting up and running PowerShell on Linux Ubuntu Desktop.</p>
    </header>

    <!-- 1. Core Cmdlets -->
    <section class="card">
      <h2>1. Getting Started with PowerShell Core Cmdlets</h2>
      <p>The foundation of PowerShell lies in its cmdlets. Cmdlets are small, task-specific commands that perform a variety of powerful actions. Traditional command-line utilities such as CMD or Bash output data as plain text, whereas PowerShell cmdlets output rich objects. This difference enables cleaner automation and makes data manipulation easier and more intuitive.</p>
      <p>The <strong>Get-Help</strong> and <strong>Get-Command</strong> cmdlets are two of the most valuable tools when learning PowerShell. These cmdlets provide instant access to documentation and available commands directly from the terminal, reducing the need for constant web searches.</p>
      <p>The <strong>Get-Help</strong> cmdlet displays built-in documentation for commands (cmdlets), allowing you to view syntax, parameters, and even full usage examples without leaving the shell. Making it an excellent resource for technicians exploring automation.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Help.png" alt="Get-Help example" /></div>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Help-Cmdlet1.png" alt="Get-Help-Cmdlet1" /></div>
      <p>The<strong>Get-Command</strong> cmdlet lists every available cmdlet or function on a given system, making it easy to discover what PowerShell can do in your current environment.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Command.png" alt="Get-Command example" /></div>
      <p>Next, cmdlets like <strong>Get-Process</strong> and <strong>Get-Service</strong> provide the ability to monitor system performance and service health without relying on tools like Task Manager or Services.msc. This shift alone saves time and integrates perfectly into scripts or automated reports.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Process.png" alt="Get-Process example" /></div>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Service.png" alt="Get-Service example" /></div>
      <p>Finally, <strong>Get-EventLog</strong> gives access to the Windows Event Logs directly from PowerShell — a massive advantage for troubleshooting or generating log summaries. You can query event data with filters to pinpoint issues much faster than manually scanning logs.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-EventLog1.png" alt="Get-EventLog example 1" /></div>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-EventLog2.png" alt="Get-EventLog example 2" /></div>
    </section>

    <!-- 2. Pipelines -->
    <section class="card">
      <h2>2. Working with Pipelines</h2>
      <p>The pipeline is one of PowerShell’s greatest strengths. Instead of passing plain text between commands, PowerShell pipelines pass entire objects — complete with properties and methods. This makes filtering, sorting, and transforming data extremely efficient.</p>
      <p>The examples below chain multiple cmdlets together to pull data from one source, filter it, and output clean results. Once you become more comfortable using pipelines, your workflow starts to evolve, repetitive data filtering and log parsing tasks become quick one-liners.</p>
      <p>Here, PowerShell takes raw process data and refines it through filtering and sorting stages, something that would require complex loops or string parsing in older scripting languages.</p>
      <div class="figure zoom"><img src="Images/Piping Examples/PipeExample1.png" alt="Pipeline example 1" /></div>
      <div class="figure zoom"><img src="Images/Piping Examples/PipeExample2.png" alt="Pipeline example 2" /></div>
    </section>

    <!-- 3. Accessing Data -->
    <section class="card">
      <h2>3. Accessing Data the Easy Way (No String Parsing Needed)</h2>
      <p>In traditional shells like CMD and Bash, data is returned as plain text. This often requires string parsing to extract the information you need. PowerShell eliminates that limitation entirely by returning structured objects with accessible properties.</p>
      <p>For example, when you query system or network information, you don’t need to rely on text manipulation. Instead, you can directly call object properties such as <code>.Status</code>, <code>.Name</code>, or <code>.CPU</code>.</p>
      <p>The comparison below shows how PowerShell replaces traditional string parsing logic. In CMD, you’d typically run a command like <code>sc query spooler</code> and then manually parse the output to find the service status.</p>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/scspooler.png" alt="Service query example" /></div>
      <p>In PowerShell, that same task is simplified with <code>Get-Service spooler</code>, which outputs a structured object you can query directly, no parsing required.</p>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/PSSpooler.png" alt="PowerShell data access example" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/AccessDataEx2.png" alt="Access data example 2" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/AccessDataEx3.png" alt="Access data example 3" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/DataAccessEx4.png" alt="Access data example 4" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/QuerySysInfo.png" alt="Query system info example" /></div>
    </section>

    <!-- 4. Scripting -->
    <section class="card">
      <h2>4. Simple Scripts to Save Time</h2>
      <p>PowerShell scripting takes repetitive tasks, such as monitoring disk space or verifying service status and turns them into reusable workflows where automation can be applied. Even short scripts can make a huge difference in day-to-day IT operations.</p>
      <p>What makes PowerShell stand out here is that every script can be modular, meaning you can break down logic into functions, reuse variables, and scale these scripts into larger automation frameworks over time.</p>
      <div class="figure zoom"><img src="Images/Scripting Examples/ScriptEx1.png" alt="Script example 1" /></div>
      <div class="figure zoom"><img src="Images/Scripting Examples/ScriptEx2.png" alt="Script example 2" /></div>
    </section>

    <!-- 5. OS Interaction -->
    <section class="card">
      <h2>5. Interacting with the Operating System</h2>
      <p>PowerShell allows you to control nearly every aspect of the operating system. Whether it’s creating directories, copying files, managing services and processes, or inspecting network adapters, PowerShell gives you full control through a single, consistent syntax.</p>
      <p>With the <strong>Stop-Service</strong> cmdlet, you can stop a running service directly without opening the Services console. Perfect for quick troubleshooting or scripting service restarts.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Stop-Service.png" alt="Stop service example" /></div>
      <p>Using <strong>New-Item</strong>, you can instantly create files, directories, or registry entries.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/New-Item.png" alt="New item 1" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/New-Item2.png" alt="New item 2" /></div>
      <p>The cmdlets <strong>Copy-Item</strong> and <strong>Remove-Item</strong> provide complete control over the filesystem. Together, these form the backbone of automated deployment, cleanup, and configuration scripts.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Get-Help-Copy-Item.png" alt="Get-help for copy item" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Copy-ItemEx.png" alt="Copy item example" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Remove-Item.png" alt="Remove item example" /></div>
      <p>Finally, with <strong>Get-NetAdapter</strong> and <strong>Get-ComputerInfo</strong>, you can instantly gather network and system details for inventory, troubleshooting, or reporting. All without clicking through a single GUI.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Get-NetAdapter.png" alt="Network adapter example" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Get-ComputerInfo.png" alt="Get computer info example" /></div>
    </section>

    <!-- 6. Cross Platform -->
    <section class="card">
      <h2>6. Running PowerShell on Linux Ubuntu</h2>
      <p>One of the most exciting developments in recent years with .NET Core is PowerShell’s expansion into Linux. It’s no longer a Windows-only tool! You can now use the same commands and scripts across different operating systems, making PowerShell truly cross-platform.</p>
      <p>In this section, I walk through installing PowerShell on Linux Ubuntu Desktop and running a few simple commands to confirm functionality. These screenshots represent the process from package updates to the final PowerShell installation.</p>
      <div class="figure full"><img src="Images/Cross-Platform Examples/aptupdate.png" alt="apt update example" /></div>
      <div class="figure full"><img src="Images/Cross-Platform Examples/upgrade-y.png" alt="apt upgrade -y" /></div>
      <p>Here, we install dependencies like <code>wget</code>, <code>apt-transport-https</code>, and <code>software-properties-common</code> — essential tools that ensure PowerShell can be securely downloaded and managed.</p>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/requiredpackages.png" alt="Required packages" /></div>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/MSGPGKeyImport.png" alt="MSGPG Key Import" /></div>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/aptupdateagain.png" alt="apt update again" /></div>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/installps.png" alt="Install PowerShell" /></div>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/CrossPExample.png" alt="Cross-platform example" /></div>
      <p>Once installed, PowerShell runs seamlessly on Linux, giving you access to familiar commands and automation workflows in a completely different environment. It’s a clear example of how far PowerShell has come as a cross-platform management framework.</p>
    </section>

    <p><a href="../index.html">Back to Home</a></p>

    <footer>
      <div>Mark Thompson · MTPortfolio</div>
      <div class="links">
        <a href="https://www.linkedin.com/in/mark-thompson-9361a81a9/" target="_blank" rel="noopener">LinkedIn</a> ·
        <a href="https://github.com/mark-thompson01" target="_blank" rel="noopener">GitHub</a>
      </div>
    </footer>
  </div>
</body>
</html>
