<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PowerShell in Action · Mark Thompson Portfolio</title>
  <meta name="description" content="A practical, hands-on PowerShell guide covering core cmdlets, pipelines, scripting, data handling, OS interaction, and PowerShell on Linux Ubuntu." />
  <style>
    :root {
      --bg-1:#0f1115; --bg-2:#141821; --text:#E6E7EE; --muted:#A9ADBE;
      --brand:#4DA3FF; --card-border:#2A3447; --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
    }

    html, body {height:100%}
    body {
      margin:0; color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans";
      background:
        radial-gradient(1200px 800px at 30% -20%, #1a2233 0%, transparent 70%),
        radial-gradient(1200px 800px at 90% -10%, #0e1c2f 0%, transparent 70%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      line-height:1.6; -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    }

    .wrap {max-width:1000px; margin:0 auto; padding:40px 20px 64px}

    /* Top nav - INCREASED SIZE */
    .topnav {margin:0 0 24px; display:flex; gap:18px; flex-wrap:wrap}
    .topnav a {
      color:var(--muted);
      text-decoration:none;
      padding:12px 20px;
      border-radius:12px;
      border:1px solid transparent;
      font-size:16px;
      font-weight:500;
    }
    .topnav a:hover {color:var(--text); border-color:#2a3447; background:rgba(255,255,255,.04)}
    .topnav a.active {color:var(--text); border-color:#3a4a67; background:rgba(255,255,255,.06)}

    /* Breadcrumb - INCREASED SIZE */
    .crumbs {color:var(--muted); font-size:15px; margin:4px 0 12px}
    .crumbs a {color:var(--muted); text-decoration:none}
    .crumbs a:hover {color:var(--text)}

    /* Headings - INCREASED SIZE */
    h1 {margin:8px 0 8px; font-size:clamp(32px,4.5vw,44px); font-weight:800}
    h2 {margin:14px 0 10px; font-size:26px; color:var(--brand); font-weight:700}
    p.lead {color:var(--muted); margin:10px 0 18px; font-size:clamp(17px,2.4vw,19px)}

    /* Body text - INCREASED SIZE */
    p {font-size:16px; line-height:1.65; margin:12px 0}
    ul,ol {font-size:16px; line-height:1.65; padding-left:24px; margin:10px 0}
    li {margin:6px 0}
    em {font-style:italic}
    strong {font-weight:600}
    code {
      background:#0f1424;
      border:1px solid #202a3f;
      border-radius:6px;
      padding:3px 7px;
      color:#e8eaf6;
      font:500 14.5px ui-monospace,SFMono-Regular,Menlo,Consolas,Monaco,"Courier New",monospace;
    }

    /* Links */
    a {color:var(--brand); text-decoration:none}
    a:hover {text-decoration:underline}

    /* Card - INCREASED PADDING */
    .card {
      background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));
      border:1px solid var(--card-border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px;
      margin-top:20px;
    }

    /* Figures */
    .figure {margin:20px auto; width:90%; max-width:700px;}
    .figure img {display:block; height:auto; width:100%; border-radius:8px; transition:transform 0.3s ease;}
    .zoom img:hover {transform:scale(1.03); cursor:zoom-in;}
    .full img {width:auto; max-width:100%; cursor:zoom-in;}

    /* Lightbox */
    .zb-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      cursor: grab;
      backdrop-filter: blur(3px);
    }
    .zb-overlay.is-open {display: flex;}
    .zb-stage {position: relative; max-width: 95vw; max-height: 90vh; overflow: hidden;}
    .zb-img {user-select: none; pointer-events: none; transform-origin: 0 0; will-change: transform;}
    .zb-close {
      position: fixed;
      top: 14px;
      right: 14px;
      background: rgba(255,255,255,.08);
      border: 1px solid #2a2f3f;
      color: #cfd3e6;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 14px;
      z-index: 10000;
      cursor: pointer;
    }
    .zb-close:hover {background: rgba(255,255,255,.12);}
    .zb-hint {
      position: fixed;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      color: #cfd3e6;
      background: rgba(255,255,255,.08);
      border: 1px solid #2a2f3f;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    /* Footer - MATCHING MAIN PAGE */
    footer {
      margin-top:48px;
      padding-top:24px;
      padding-bottom:2px;
      border-top:1px solid #232a3a;
      color:var(--muted);
      font-size:0.9rem;
      background:linear-gradient(
        to bottom,
        rgba(20,24,33,0) 0%,
        rgba(20,24,33,0.65) 100%
      );
      flex-shrink:0;
    }
    footer .links {
      margin-top:6px;
      gap:8px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
    }
    footer a {
      color:var(--muted);
      text-decoration:none;
      white-space:nowrap;
    }
    footer a:hover {color:var(--brand)}
  </style>
</head>
<body>
  <div class="wrap">

    <nav class="topnav" aria-label="Sections">
      <a href="/MTPortfolio/">Home</a>
      <a href="/MTPortfolio/Skills">Networking</a>
      <a href="/MTPortfolio/Current%20Projects%20&%20Studies/">Windows & Linux</a>
      <a href="/MTPortfolio/Lab%20Projects">Cybersecurity</a>
      <a href="/MTPortfolio/Blogs" class="active">Blog</a>
    </nav>

    <div class="crumbs">
      <a href="/MTPortfolio/Blogs">Blog</a> · <span>PowerShell in Action</span>
    </div>

    <header>
      <div class="figure">
        <img src="Images/PowerShellInAction.png" alt="PowerShell in Action blog header" style="width:600px; height:auto;" loading="lazy" />
      </div>
      <h1>PowerShell in Action: Hands-on Examples That Change How You Work</h1>
      <p class="lead">A hands-on continuation of my previous PowerShell blog that takes a practical approach to showing how PowerShell changes the way you interact with a system.</p>
      <p>It kicks off with core cmdlets and continues with examples that demonstrate the power of pipelines, working with structured data instead of string parsing, creating simple scripts to save time, interacting with the operating system, and finally, setting up and running PowerShell 7.5 on Ubuntu Desktop 24.04.</p>
    </header>

    <!-- 1. Core Cmdlets -->
    <section class="card">
      <h2>1. Getting Started with PowerShell Core Cmdlets</h2>
      <p>The foundation of PowerShell lies in its cmdlets. Cmdlets are small, task-specific commands that perform a variety of powerful actions. Traditional command-line utilities such as CMD or Bash output data as plain text, whereas PowerShell cmdlets output rich objects. This difference enables cleaner automation and makes data manipulation easier and more intuitive.</p>
      <p>The <strong>Get-Help</strong> and <strong>Get-Command</strong> cmdlets are two of the most valuable tools when learning PowerShell. These cmdlets provide instant access to documentation and available commands directly from the terminal, reducing the need for constant web searches.</p>
      <p>The <strong>Get-Help</strong> cmdlet displays built-in documentation for commands (cmdlets), allowing you to view syntax, parameters, and even full usage examples without leaving the shell. This makes it an excellent resource for technicians exploring automation.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Help.png" alt="Get-Help example" /></div>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Help-Cmdlet1.png" alt="Get-Help Cmdlet Example" /></div>
      <p>The <strong>Get-Command</strong> cmdlet lists every available cmdlet or function on a given system, making it easy to discover what PowerShell can do in the current environment.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Command.png" alt="Get-Command example" /></div>
      <p>The cmdlets <strong>Get-Process</strong> and <strong>Get-Service</strong> provide the ability to monitor system performance and service health without relying on tools like Task Manager or Services.msc. This shift alone saves time and integrates perfectly into scripts or automated reports.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Process.png" alt="Get-Process example" /></div>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-Service.png" alt="Get-Service example" /></div>
      <p>Finally, the <strong>Get-EventLog</strong> cmdlet gives access to Windows Event Logs directly from PowerShell, a massive advantage for troubleshooting or generating log summaries.</p>
      <p><em>Note:</em> On modern systems running PowerShell 7 and later, the <strong>Get-WinEvent</strong> cmdlet is preferred, as <strong>Get-EventLog</strong> is considered legacy and primarily supported for backward compatibility.</p>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-EventLog1.png" alt="Get-EventLog example 1" /></div>
      <div class="figure zoom"><img src="Images/Core Cmdlets/Get-EventLog2.png" alt="Get-EventLog example 2" /></div>
    </section>

    <!-- 2. Pipelines -->
    <section class="card">
      <h2>2. Working with Pipelines</h2>
      <p>The pipeline is one of PowerShell's greatest strengths and advantages. Instead of passing plain text between commands, PowerShell pipelines pass entire objects, complete with properties and methods. This makes filtering, sorting, and transforming data extremely efficient.</p>
      <p>The examples below chain multiple cmdlets together to pull data from one source, filter it, and output clean results. Once you become more comfortable using pipelines, your workflow starts to evolve, repetitive data filtering and log parsing tasks become quick one-liners.</p>
      <div class="figure zoom"><img src="Images/Piping Examples/PipeExample1.png" alt="Pipeline example 1" /></div>
      <div class="figure zoom"><img src="Images/Piping Examples/PipeExample2.png" alt="Pipeline example 2" /></div>
    </section>

    <!-- 3. Accessing Data -->
    <section class="card">
      <h2>3. Accessing Data the Easy Way (No String Parsing Needed)</h2>
      <p>In traditional shells like CMD and Bash, data is returned as plain text. This often requires string parsing to extract the information you need. PowerShell eliminates that limitation entirely by returning structured objects with accessible properties.</p>
      <p>For example, when you query system or network information, you don't need to rely on text manipulation. Instead, you can directly call object properties such as <code>.Status</code>, <code>.Name</code>, or <code>.CPU</code>.</p>
      <p>The comparison below shows how PowerShell replaces traditional string parsing logic. In CMD, you'd typically run a command like <code>sc query spooler</code> and then manually parse the output to find the service status.</p>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/scspooler.png" alt="CMD service query example" /></div>
      <p>In PowerShell, that same task is simplified with <code>Get-Service spooler</code>, which outputs a structured object you can query directly, no parsing required.</p>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/PSSpooler.png" alt="PowerShell Get-Service example" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/AccessDataEx2.png" alt="Access data example 2" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/AccessDataEx3.png" alt="Access data example 3" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/DataAccessEx4.png" alt="Access data example 4" /></div>
      <div class="figure zoom"><img src="Images/Access Data Without String Parsing/QuerySysInfo.png" alt="Query system info example" /></div>
    </section>

    <!-- 4. Scripting -->
    <section class="card">
      <h2>4. Simple Scripts to Save Time</h2>
      <p>PowerShell scripting turns repetitive tasks such as monitoring disk space or verifying service status into reusable workflows that can easily be automated. Even short scripts can make a huge difference in day-to-day IT operations.</p>
      <p>What makes PowerShell stand out here is that every script can be modular, meaning you can break down logic into functions, reuse variables, and scale these scripts into larger automation frameworks over time.</p>
      <div class="figure zoom"><img src="Images/Scripting Examples/ScriptEx1.png" alt="Script example 1" /></div>
      <div class="figure zoom"><img src="Images/Scripting Examples/ScriptEx2.png" alt="Script example 2" /></div>
    </section>

    <!-- 5. OS Interaction -->
    <section class="card">
      <h2>5. Interacting with the Operating System</h2>
      <p>PowerShell allows you to control nearly every aspect of the operating system. Whether you're creating directories, copying files, managing services and processes, or inspecting network adapters, PowerShell provides full control through a single, consistent syntax.</p>
      <p>With the <strong>Stop-Service</strong> cmdlet, you can stop a running service directly without opening the Services console. Perfect for quick troubleshooting or scripting service restarts.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Stop-Service.png" alt="Stop service example" /></div>
      <p>Using <strong>New-Item</strong>, you can instantly create files, directories, or registry entries.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/New-Item.png" alt="New item example 1" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/New-Item2.png" alt="New item example 2" /></div>
      <p>The cmdlets <strong>Copy-Item</strong> and <strong>Remove-Item</strong> provide complete control over the filesystem. Together, these form the backbone of automated deployment, cleanup, and configuration scripts.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Get-Help-Copy-Item.png" alt="Get-Help Copy-Item" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Copy-ItemEx.png" alt="Copy item example" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Remove-Item.png" alt="Remove item example" /></div>
      <p>Finally, with the <strong>Get-NetAdapter</strong> and <strong>Get-ComputerInfo</strong> cmdlets, you can instantly gather network and system details for inventory, troubleshooting, or reporting. All without clicking through a single GUI.</p>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Get-NetAdapter.png" alt="Get-NetAdapter example" /></div>
      <div class="figure zoom"><img src="Images/OS Interaction Examples/Get-ComputerInfo.png" alt="Get-ComputerInfo example" /></div>
    </section>

    <!-- 6. Cross Platform -->
    <section class="card">
      <h2>6. Running PowerShell 7.5 on Ubuntu Desktop 24.04</h2>
      <p>One of the most exciting advancements in PowerShell's evolution with .NET Core is its expansion into Linux. It's no longer a Windows-only tool. You can now use the same commands and scripts across different operating systems, making PowerShell truly cross-platform.</p>
      <p>In this section, I walk through installing PowerShell 7.5 on Ubuntu Desktop 24.04 and running a few simple commands to confirm functionality. These screenshots represent the process from package updates to the final PowerShell installation.</p>
      <p><strong>Step 1:</strong> Update package lists</p>
      <div class="figure full"><img src="Images/Cross-Platform Examples/aptupdate.png" alt="apt update example" /></div>
      <div class="figure full"><img src="Images/Cross-Platform Examples/upgrade-y.png" alt="apt upgrade -y example" /></div>
      <p><strong>Step 2:</strong> Install prerequisites</p>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/requiredpackages.png" alt="Required packages" /></div>
      <p><strong>Step 3:</strong> Import Microsoft GPG Key</p>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/MSGPGKeyImport.png" alt="MSGPG key import" /></div>
      <p><strong>Step 4:</strong> Install PowerShell</p>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/aptupdateagain.png" alt="apt update again" /></div>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/installps.png" alt="Install PowerShell" /></div>
      <p><strong>Step 5:</strong> Launch PowerShell</p>
      <div class="figure zoom"><img src="Images/Cross-Platform Examples/CrossPExample.png" alt="Cross-platform example" /></div>
    </section>

    <!-- 7. Conclusion -->
    <section class="card">
      <p>Building these examples reminded me why I enjoy PowerShell so much. It's not just about commands—it's about efficiency, creativity, and control.</p>
      <p>Whether you are maintaining servers, automating reports, or experimenting in your own environment, PowerShell gives you the tools to truly shape how you work and to approach every task with a mindset focused on precision and automation.</p>
    </section>

    <p><em>PowerShell is a trademark of Microsoft Corporation. This content is for educational purposes and is not affiliated with or endorsed by Microsoft.</em></p>

    <p><a href="../index.html">Back to Home</a></p>

    <footer>
      <div>Mark Thompson · MTPortfolio</div>
      <div class="links">
        <a href="https://www.linkedin.com/in/mark-thompson-9361a81a9/" target="_blank" rel="noopener">LinkedIn</a> ·
        <a href="https://github.com/mark-thompson01" target="_blank" rel="noopener">GitHub</a>
      </div>
    </footer>
  </div>

  <!-- Lightbox Script -->
  <script>
    const imgs = Array.from(document.querySelectorAll('.zoom img, .full img'));
    const overlay = document.createElement('div');
    overlay.className = 'zb-overlay';
    overlay.innerHTML = `
      <button class="zb-close">Close</button>
      <div class="zb-stage"><img class="zb-img" /></div>
      <div class="zb-hint">Scroll to zoom · Drag to pan · Double-click to toggle zoom · Click outside or press Esc to close</div>
    `;
    document.body.appendChild(overlay);

    const stage = overlay.querySelector('.zb-stage');
    const zimg = overlay.querySelector('.zb-img');
    const closeBtn = overlay.querySelector('.zb-close');
    let scale = 1, originX = 0, originY = 0, startX = 0, startY = 0, isPanning = false;

    function applyTransform() {
      zimg.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
    }
    function open(src) {
      zimg.src = src;
      scale = 1; originX = 0; originY = 0;
      applyTransform();
      overlay.classList.add('is-open');
    }
    function close() {
      overlay.classList.remove('is-open');
      zimg.src = '';
    }

    imgs.forEach(img => img.addEventListener('click', () => open(img.src)));
    overlay.addEventListener('click', e => { if(e.target === overlay) close(); });
    closeBtn.addEventListener('click', close);
    window.addEventListener('keydown', e => { if(e.key === 'Escape') close(); });

    stage.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = -Math.sign(e.deltaY) * 0.15;
      scale = Math.max(1, Math.min(5, scale + delta));
      applyTransform();
    }, {passive: false});

    stage.addEventListener('mousedown', e => {
      if (scale <= 1) return;
      isPanning = true;
      startX = e.clientX - originX;
      startY = e.clientY - originY;
    });
    window.addEventListener('mousemove', e => {
      if (!isPanning) return;
      originX = e.clientX - startX;
      originY = e.clientY - startY;
      applyTransform();
    });
    window.addEventListener('mouseup', () => { isPanning = false; });

    stage.addEventListener('dblclick', () => {
      scale = (scale > 1.2) ? 1 : 2.5;
      applyTransform();
    });
  </script>
</body>
</html>
